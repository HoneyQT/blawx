{% load static %}
{% load guardian_tags %}

<!DOCTYPE html>
<html lang="en" class="vh-100">
<head>
    <title>Blawx - Drag and Drop Legal AI</title>
    <link rel="apple-touch-icon" sizes="180x180" href="{% static 'blawx/apple-touch-icon.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'blawx/favicon-32x32.png' %}">
    <link rel="icon" type="image/png" sizes="16x16" href="{% static 'blawx/favicon-16x16.png' %}">
    <link rel="manifest" href="{% static 'blawx/site.webmanifest' %}">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <link rel="stylesheet" href="{% static 'blawx/bootstrap.min.css' %}">
    <script src="{% static 'blawx/bootstrap.bundle.min.js' %}"></script>
<!--     
    <link href="https://fonts.googleapis.com/css2?family=Mina:wght@700&amp;display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@500&amp;display=swap" rel="stylesheet"> -->
    <link href="{% static 'blawx/fonts.css' %}" rel="stylesheet">
    <style type="text/css">
        #blawxlogo {
            font-family: 'Mina', sans-serif;
            font-size: xx-large;
            color: #5a005a;
        }

        #blawxWordMark {
            font-family: 'IBM Plex Sans', sans-serif;
        }
    </style>
    

    <link href="{% static 'blawx/navtree.css' %}" rel="stylesheet">
    <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css" rel="stylesheet"> -->
    <link href="{% static 'blawx/bootstrap-icons.css' %}" rel="stylesheet">

    <script src="{% static 'blawx/jquery.min.js' %}"></script>
    {% get_obj_perms request.user for blawxtest as 'blawxtest_perms' %}
</head>
<body class="container d-flex flex-column vh-100">
    {% csrf_token %}
    <header class="py-3 mb-3 border-bottom">
        <div class="row">
            <div class="col-2 align-self-center" id="blawxlogo"><a href="/" style="text-decoration: none; color: #5a005a;">ยง<span id="blawxWordMark">Blawx</span></a></div>
            <div class="col-8">
                <a href="javascript:void(0);" class="btn btn-secondary btn-disabled" onclick="run_test()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-caret-right-square" viewBox="0 0 16 16">
                        <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
                        <path d="M5.795 12.456A.5.5 0 0 1 5.5 12V4a.5.5 0 0 1 .832-.374l4.5 4a.5.5 0 0 1 0 .748l-4.5 4a.5.5 0 0 1-.537.082z"/>
                    </svg>
                    <span class="text">Run</span>
                </a>
                <a href="/docs/home" target=_blank class="btn btn-secondary">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                        class="bi bi-question-square" viewBox="0 0 16 16">
                        <path
                            d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z" />
                        <path
                            d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z" />
                    </svg>
                    <span class="text">Help</span>
                </a>
                <a href="{% url 'test' blawxtest.ruledoc.id blawxtest %}" class="btn btn-secondary">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                        class="bi bi-x-square" viewBox="0 0 16 16">
                        <path
                            d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z" />
                        <path
                            d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z" />
                    </svg>
                    <span class="text">Exit</span>
                </a>
            </div>
            {% if user.is_authenticated %}
            <div class="col-2">{{ user.username }} | <a href="{% url 'password_change' %}">Change Password</a> | <a href="{% url 'logout' %}">Logout</a></div>
        {% else %}
            <div class="col-2"><a href="{% url 'login' %}">Login</a></div>
        {% endif %}
        </div>
    </header>
    <div class="row">
        <div class="collapse-horizontal flex-column card col-12 collapse show p-0">
        <nav class="card-header">
            <div class="nav nav-tabs card-header-tabs" id="nav-tab" role="tablist">
              <button class="nav-link active" id="nav-facts-tab" data-bs-toggle="tab" data-bs-target="#nav-facts" type="button" role="tab" aria-controls="nav-facts" aria-selected="true">Facts</button>
              <button class="nav-link" id="nav-answers-tab" data-bs-toggle="tab" data-bs-target="#nav-answers" type="button" role="tab" aria-controls="nav-answers" aria-selected="false">Answers</button>
              <button class="nav-link" id="nav-view-tab" data-bs-toggle="tab" data-bs-target="#nav-view" type="button" role="tab" aria-controls="nav-view" aria-selected="false">View</button>
              <button class="nav-link" id="nav-devel-tab" data-bs-toggle="tab" data-bs-target="#nav-devel" type="button" role="tab" aria-controls="nav-devel" aria-selected="false">Devel</button>
            </div>
          </nav>
          <div class="tab-content card-body" id="nav-tabContent">
            <div class="tab-pane fade show active" id="nav-facts" role="tabpanel" aria-labelledby="nav-facts-tab">
                <div id="facttree" class="blawx-category tree-element p-2">
                </div>
                <div>
                    <button class="btn btn-success my-2 {% if 'change_blawxtest' not in blawxtest_perms %}disabled{% endif %}" {% if 'change_blawxtest' not in blawxtest_perms %}aria-disabled="true" {% endif %}onclick="save_fact_scenario()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-save" viewBox="0 0 16 16">
                            <path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v7.293l2.646-2.647a.5.5 0 0 1 .708.708l-3.5 3.5a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L7.5 9.293V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"></path>
                        </svg>
                        <span class="text">Save Default Fact Scenario</span>
                    </button>
                </div>
            </div>
            <div class="tab-pane fade" id="nav-answers" role="tabpanel" aria-labelledby="nav-answers-tab">
                <div class="container py-3">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="card-title">Answers</h5>
                            <div id="answers">
                                <!-- The answers will go here. -->
                            </div>
                        </div>
        
                    </div>
                </div>
            </div>
            <div class="tab-pane fade" id="nav-view" role="tabpanel" aria-labelledby="nav-view-tab">
                <div class="container py-3">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="card-title">View</h5>
                            <div id="viewform">
                                <!-- The view editor will go here. -->
                            </div>
                            <div>
                                <button class="btn btn-success {% if 'change_blawxtest' not in blawxtest_perms %}disabled{% endif %}" {% if 'change_blawxtest' not in blawxtest_perms %}aria-disabled="true" {% endif %}onclick="save_view()">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-save" viewBox="0 0 16 16">
                                        <path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v7.293l2.646-2.647a.5.5 0 0 1 .708.708l-3.5 3.5a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L7.5 9.293V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"></path>
                                    </svg>
                                    <span class="text">Save Default View</span>
                                </button>
                            </div>
                        </div>
        
                    </div>
                </div>
            </div>
            <div class="tab-pane fade" id="nav-devel" role="tabpanel" aria-labelledby="nav-devel-tab">
                <div class="container py-3">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="card-title">Devel</h5>
                            This tab shows the payload sent to the Blawx interview API, and the response
                            received, to illustrate use of the Blawx interview API for developers.
                            <h6>Payload</h6>
                            <div id="payload">
                                <!-- The payload will go here. -->
                            </div>
                            <h6>Response</h6>
                            <div id="response">
                                <!-- The response will go here. -->
                            </div>
                        </div>
        
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>
    <footer class="footer mt-auto py-3 bg-light">
        <div class="container">
            <span>Copyright &copy; Lexpedite Legal Technology Ltd. 2022-2023</span> | <span>{{ BLAWX_VERSION }}</span>
        </div>
    </footer>
    <script>
        
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        const csrftoken = getCookie('csrftoken');

        // Get the ontology
        var parsed_test_response = {'Relevant Attributes': [], 'Relevant Categories': []};
        var ontology = {};
        var fact_data = {};
        var new_fact_data = {'facts': []};
        var hidden_by_view = [];
        const ontology_request = new XMLHttpRequest();
        ontology_request.onload = function () {
            ontology = JSON.parse(this.responseText);
            if(ontology.View != "") {
                hidden_by_view = ontology.View;
            }
            if(ontology.Facts != "") {
                new_fact_data = ontology.Facts;
            } else {
                initialize_facts();
            }
            console.log("Ontology received");
        }
        ontology_request.open("GET", "{% url 'test_onto' blawxtest.ruledoc.id blawxtest %}", false); // This is asynchronous because the interview request doesn't work until we have the ontology.
        ontology_request.setRequestHeader('X-CSRFToken', csrftoken);
        ontology_request.send();


        var expanded={}; // A list of tree elements that have been expanded.
        var section_texts = {};
        function addSectionReferences(text,human) {
            if (text.charAt(0) === text.charAt(0).toUpperCase()) {
                return "any section"; // This is variable, return it as is.
            }
            if (!(text+human in section_texts)) {

                // Search the string for the list of section references
                var xhttp = new XMLHttpRequest();
                xhttp.open("GET", "../../../rule/" + text.slice(0,-8) + "/", false);
                xhttp.setRequestHeader('X-CSRFToken', csrftoken);
                xhttp.send();
                output_object = JSON.parse(xhttp.responseText);
                rule_text = output_object['text'];
                var new_text = text.replace(/(sec_.*)_section/g, "$1");
                new_text = new_text.replace(/sec_/g, "section ");
                new_text = new_text.replace(/__subsec_/g, " subsection ");
                new_text = new_text.replace(/__para_/g, " paragraph ");
                new_text = new_text.replace(/__subpara_/g, ' sub-paragraph ');
                new_text = new_text.replace(/__span_/g, ' span ');
                output = ""
                if (human) {output = '<a href="#" data-bs-toggle="tooltip" data-bs-html="true" title="' + rule_text + '">';}
                output += new_text;
                if (human) {output += '</a>'}
                section_texts[text+human] = output;
                }
            return section_texts[text+human];
        }

        var excluded = ['datetime_diff_duration',
        'lte',
        'average_blawx_list',
        'sum_blawx_list',
        'count_blawx_list',
        'min_blawx_list',
        'max_blawx_list',
        'before',
        'after',
        'not_before',
        'not_after',
        'eq',
        'lt',
        'gt',
        'gte',
        'blawx_now',
        'blawx_today',
        'build_datetime',
        'datetime_add',
        'datetime_diff',
        'datetime_add_days',
        'days_between_datetimes',
        'is'];

        function getNodeName(node,answer,explanation) {
            var node_name = "";
            var statement = node;
            if (statement != "query" && statement != "o_nmr_check") {

                var predicate = statement.functor;
                if (predicate == "proved") { // this is a reference to something for which there is already a node
                    return getNodeName(statement.args[0],answer,explanation)
                }
                var parameters = statement.args;
                var prefix = "ans" + answer + "_expl" + explanation + "_"
                var node_name = prefix + "_" + predicate
                for (var i =0; i < parameters.length; i++) {
                    node_name += "_" + displayValue(parameters[i],false).replace("'",'_').replace('.','_')
                }
            } else {
                node_name = statement;
            }
            return encodeURIComponent(node_name).replace('%','_').replace('(','_').replace(')','_');
        }

        // Have a global dictionary of nodes, just by reference and name
        // Generate a list of the nodes we actually need by name.
        // Display those nodes using the dictionary to find the source node.

        var explanation_node_index = {};
        function getExplanationNodeIndex(model,answer,explanation) {
            var new_node_name = getNodeName(model.args[0],answer,explanation);
            if(!(new_node_name in explanation_node_index)) {
                explanation_node_index[new_node_name] = model;
            }
            var reasons = model.args[1];
            for (var i = 0; i < reasons.length; i++) {
                getExplanationNodeIndex(reasons[i],answer,explanation);
            }
        }

        function getNodesFromModel(model,show_this_node,answer,explanation) {
            // The structure looks like this
            // functor: -, args: statement, reasons
            // statement {functor: predicate, args: parameters}
            // reasons: [new structures]
            var node_list = [];
            // In the current node, we need the statement, and we need the reasons
            var statement = model.args[0];
            var reasons = model.args[1];
            var predicate = statement.functor;
            var parameters = statement.args;
            var node_name = getNodeName(model,answer,explanation)
            var show_subnodes = false;
            var target=model;
            if(predicate == "proved") {
                // If a node is proved elsewhere, we need to find where it is proved, and add that proof here.
                // This is to avoid situations where the node is proved inside the elided part of an excluded
                // predicate only, and so will never be generated otherwise.
                // We need to search the tree for where the node is proved, and convert that node instead.
                // But this is a recursive algorithm that doesn't have access to the tree above it, which has
                // already been processed.
                // Now I have access to the node models by name because of the index, so I get the name of the
                // first argument, get the model from the index, and change the target to that model.
                var proved_statement = getNodeName(parameters[0],answer,explanation)
                target = explanation_node_index[proved_statement];
            }
            if(statement == "query") {
                show_subnodes = true;
            }
            var new_node = {'name': node_name, 'content': convertNodeToParagraph(target,show_this_node,answer,explanation)}
            node_list.push(new_node);
            var subnodes = [];
            if (!excluded.includes(predicate)) {
                for (var i=0; i < reasons.length; i++) {
                    subnodes = subnodes.concat(getNodesFromModel(reasons[i],show_subnodes,answer,explanation));
                }
            }
            for (var i=0; i < subnodes.length; i++) {
                if(!node_list.includes(subnodes[i])) {
                    node_list.push(subnodes[i]);
                }
            }
            return node_list;
        }

        function convertNodeToParagraph(node,show,answer,explanation) {
            var output_html = "";
            var statement = node.args[0]
            output_html += '<div class="new_explanation collapse';
            if (show) {
                output_html += " show";
            }
            output_html +='" id="' + getNodeName(statement,answer,explanation) + '">';
            var reasons = node.args[1]
            var predicate_name = node.args[0].functor

            if(statement != "query" && statement != "o_nmr_check") {
                var statement_nlg = answerNLG(statement,true);
                var negated = statement_nlg.match('there is no evidence that'); // is this a negated fact?
                var assumed = statement_nlg.match('it is assumed that'); // is this an assumption?
                var text_output = ""
                output_html += "<p>"
                if (!excluded.includes(predicate_name) && !negated && !assumed) {
                    // Here we will need to check for assumptions, so they can be displayed.
                    text_output += "We know "
                } else if (!negated && !assumed) {
                    text_output += "We can calculate that "
                }
                text_output += statement_nlg;

                output_html += text_output.charAt(0).toUpperCase() + text_output.slice(1)
                // If there are sub-justifications, add the NLG for each sub-justification, and add it
                // as a collapsible link.
                
                if (reasons.length && !excluded.includes(predicate_name) ) {
                    var displayed_reasons = [];
                    output_html += " because <ul>";
                    for(var i=0; i< reasons.length; i++) {
                        if (!displayed_reasons.includes(getNodeName(reasons[i].args[0],answer,explanation))) { // This is used to get rid of duplicate sub-goals in explanations for constructively negated predicates.
                            if(i == reasons.length-1 && reasons.length > 1) {
                                output_html += " and "
                            }
                            output_html += '<li>';
                            displayed_reasons.push(getNodeName(reasons[i].args[0],answer,explanation));
                            output_html += answerNLG(reasons[i].args[0],true);
                            output_html += '<a title="How do we know?" class="btn btn-light p-0" data-bs-toggle="collapse" href="#' + getNodeName(reasons[i].args[0],answer,explanation) + '" data-bs-target="#' + getNodeName(reasons[i].args[0],answer,explanation) + '" role="button" aria-expanded="true" aria-controls="' + getNodeName(reasons[i].args[0],answer,explanation) + '">';
                            output_html += '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-info-square" viewBox="0 0 16 16">';
                            output_html += '<path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>';
                            output_html += '<path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>';
                            output_html += '</svg>';
                            output_html += '</a>';
                            if(i == reasons.length-1) {
                                output_html += ".";
                            }
                        }
                    }
                    output_html += "</ul>"
                    output_html += "</p>"
                } else if (!excluded.includes(predicate_name) && !negated && !assumed) { // there are no reasons, so it was specified as a fact
                        output_html += ", which was provided as a fact.</p>"
                } else {
                    output_html += ".</p>"
                }
            }
            output_html += "</div>"
            return output_html;
        }

        
        function displayValue(term,human=true) {
            var output = "";
            if(term.hasOwnProperty('functor')) {
                switch(term.functor) {
                    case 'date':
                        output = term.args[0] + "/" + term.args[1] + "/" + term.args[2]
                        break;
                    case 'datetime':
                        output = term.args[0] + "/" + term.args[1] + "/" + term.args[2] + " " + term.args[3] + ":" + term.args[4].toString().padStart(2,"0") + ":" + term.args[5].toString().padStart(2,"0")
                        break;
                    case 'duration':
                        if (term.args[0] == 1) {
                            var direction = "into the future"
                        } else {
                            var direction = "into the past"
                        }
                        output = (term.args[1] != 0 ? term.args[1] + " years, " : "") + 
                                (term.args[2] != 0 ? term.args[2] + " months, " : "") + 
                                (term.args[3] != 0 ? term.args[3] + " days, " :"") + 
                                (term.args[4] != 0 ? term.args[4] + " hours, " : "") + 
                                (term.args[5] != 0 ? term.args[5] + " minutes, " : "") +
                                (term.args[6] != 0 ? term.args[6] + " seconds " : "") + 
                                direction
                        break;
                    case 'time':
                        output = term.args[0] + ":" + term.args[1].toString().padStart(2,"0") + ":" + term.args[2].toString().padStart(2,"0")
                        break;
                    //case 'defeated':
                    //    output = answerNLG(term);
                    //    break;
                    //case 'refuted':
                    //    output = answerNLG(term);
                    //    break;
                    //case 'adbuced':
                    //    output = answerNLG(term);
                    default:
                        output = answerNLG(term,human);
                        //output = 'Unknown predicate type'
                }
            } else {
                output = term
            }
            if (human) {
                return output;
            } else {
                return encodeURIComponent(output).replaceAll('%','_').replaceAll('(','_').replaceAll(')','_').replaceAll('*','mul').replaceAll('/','div').replaceAll('+','add').replaceAll('-','sub');
            }
        }

        function answerNLG(model,human) {
            if(model == "query") { // this is the root of a model
                // This doesn't need a representation
                return "root";
            } else if(typeof(model) == 'string') {
                if (model.charAt(0) === model.charAt(0).toUpperCase()){
                    return "anything"
                }
                if (model == "o_nmr_check") {
                    return "all global constraints hold"
                }
            } else if (typeof(model) != 'object') {
                return model.toString();
            } else if (Array.isArray(model)) {
                return model.toString();
            } else if (model.functor == "-") { // this is a "because" node or known false node
                return "because";
            } else if (model.functor == "not" && model.args[0].functor != "-") {
                return "there is no evidence that " + answerNLG(model.args[0],human);
            } else if (model.functor == "not" && model.args[0].functor == "-") {
                return "it may be true that " + answerNLG(model.args[0].args[0],human);
            } else if (model.functor == "legally_holds" && model.args[1].functor != "-") {
                return "it legally holds that according to " + addSectionReferences(model.args[0],human) + ", " + answerNLG(model.args[1],human);
            } else if (model.functor == "legally_holds" && model.args[1].functor == "-") {
                return "it legally holds that it is false that according to " + addSectionReferences(model.args[0],human) + ", " + answerNLG(model.args[1].args[0],human);
            } else if (model.functor == "according_to" && model.args[1].functor != "-") {
                return "according to " + addSectionReferences(model.args[0],human) + ', ' + answerNLG(model.args[1],human);
            } else if (model.functor == "according_to" && model.args[1].functor == "-") {
                return "according to " + addSectionReferences(model.args[0],human) + ', it is not true that ' + answerNLG(model.args[1].args[0],human);
            } else if (model.functor == "defeated" && model.args[1].functor != "-") {
                return "the conclusion in " + addSectionReferences(model.args[0],human) + " that " + answerNLG(model.args[1],human) + " is defeated"
            } else if (model.functor == "defeated" && model.args[1].functor == "-") {
                return "the conclusion in " + addSectionReferences(model.args[0],human) + " that it is not true that " + answerNLG(model.args[1].args[0],human) + " is defeated"
            } else if (model.functor == "refuted" && model.args[1].functor != "-") {
                return "the conclusion in " + addSectionReferences(model.args[0],human) + " that " + answerNLG(model.args[1],human) + " is refuted"
            } else if (model.functor == "refuted" && model.args[1].functor == "-") {
                return "the conclusion in " + addSectionReferences(model.args[0],human) + " that it is not true that " + answerNLG(model.args[1].args[0],human) + " is refuted"
            } else if (model.functor == "opposes" && model.args[1].functor != "-" && model.args[0].functor != "-") { // THIS IS WRONG BECAUSE TWO THINGS MIGHT BE NEGATED...
                return "the conclusion " + answerNLG(model.args[0],human) + " opposes the conclusion " + answerNLG(model.args[1],human);
            } else if (model.functor == "opposes" && (model.args[1].functor == "-" || model.args[0].functor =="-")) {
                var output = "the concluson ";
                if (model.args[0].functor == "-") {
                    output += "it is not true that " + answerNLG(model.args[0].args[0],human);
                } else {
                    output += answerNLG(model.args[0],human);
                }
                output += " opposes the conclusion that ";
                if (model.args[1].functor == "-") {
                    output += "it is not true that " + answerNLG(model.args[1].args[0],human);
                } else {
                    output += answerNLG(model.args[1],human);
                }
                return output;
            } else if (model.functor == "overrules") {
                return addSectionReferences(model.args[0],human) + " overrules " + addSectionReferences(model.args[1],human)
            } else if (model.functor == "abduced" && model.args[0].functor != "-") {
                return "it is hypothesized that " + answerNLG(model.args[0],human);
            } else if (model.functor == "abduced" && model.args[0].functor == "-") {
                return "it is hypothesized that it is not the case that " + answerNLG(model.args[0].args[0],human);
            } else if (model.functor == "proved" && model.args[0].functor != "-" ) { 
                return answerNLG(model.args[0],human); // Just display the NLG for the thing that was proved.
            } else if (model.functor == "proved" && model.args[0].functor == "-" ) { 
                return "it is not true that " + answerNLG(model.args[0].args[0],human);
            } else if (model.functor == "chs" && model.args[0].functor != "-") {
                return "it is assumed that " + answerNLG(model.args[0],human);
            } else if (model.functor == "chs" && model.args[0].functor == "-") {
                return "it is assumed that it is not true that " + answerNLG(model.args[0].args[0],human);
            } else if (model.functor == "findall") {
                return "finding all " + answerNLG(model.args[0],human) + " in " + answerNLG(model.args[1],human) + " gives " + answerNLG(model.args[2],human)
            } else if (model.functor == "count_blawx_list") {
                return "there are " + answerNLG(model.args[1],human) + ' elements in ' + answerNLG(model.args[0],human)
            } else if (model.functor == "average_blawx_list") {
                return "the average of " + answerNLG(model.args[0],human) + ' is ' + answerNLG(model.args[1],human)
            } else if (model.functor == "sum_blawx_list") {
                return "the sum of " + answerNLG(model.args[0],human) + ' is ' + answerNLG(model.args[1],human)
            } else if (model.functor == "max_blawx_list") {
                return "the maximum of " + answerNLG(model.args[0],human) + ' is ' + answerNLG(model.args[1],human)
            } else if (model.functor == "min_blawx_list") {
                return "the minimum of " + answerNLG(model.args[0],human) + ' is ' + answerNLG(model.args[1],human)
            } else if (model.functor == "before") {
                return displayValue(model.args[0],human) + ' is before ' + displayValue(model.args[1],human);
            } else if (model.functor == "after") {
                return displayValue(model.args[0],human) + ' is after ' + displayValue(model.args[1],human);
            } else if (model.functor == "not_before") {
                return displayValue(model.args[0],human) + ' is not before ' + displayValue(model.args[1],human);
            } else if (model.functor == "not_after") {
                return displayValue(model.args[0],human) + ' is not after ' + displayValue(model.args[1],human);
            } else if (model.functor == "eq") {
                return displayValue(model.args[0],human) + ' is equal to ' + displayValue(model.args[1],human);
            } else if (model.functor == "blawx_now") {
                return "the current datetime is " + displayValue(model.args[0],human);
            } else if (model.functor == "blawx_today") {
                return "today is " + displayValue(model.args[0],human);
            } else if (model.functor == "build_datetime") {
                return "the date " + displayValue(model.args[0],human) + " and the time " + displayValue(model.args[1],human) + " correspond to the datetime " + displayValue(model.args[2],human)
            } else if (model.functor == "datetime_add") {
                return displayValue(model.args[0],human) + " modified by " + displayValue(model.args[1],human) + " gives " + displayValue(model.args[2],human)
            } else if (model.functor == "datetime_diff") {
                return "from " + displayValue(model.args[0],human) + " to " + displayValue(model.args[1],human) + " is " + displayValue(model.args[2],human)
            } else if (model.functor == "datetime_add_days") {
                return displayValue(model.args[0],human) + " plus " + displayValue(model.args[1],human) + " days gives " + displayValue(model.args[2],human)
            } else if (model.functor == "days_between_datetimes") {
                return "from" + displayValue(model.args[0],human) + " to " + displayValue(model.args[1],human) + " in days is " + displayValue(model.args[2],human)
            } else if (model.functor == "is") {
                return displayValue(model.args[0],human) + " = (" + answerNLG(model.args[1],human) + ")"
            } else if (model.functor == "+") {
                return "(" + answerNLG(model.args[0],human) + " + " + answerNLG(model.args[1],human) + ")";
            } else if (model.functor == "-") {
                return "(" + answerNLG(model.args[0],human) + " - " + answerNLG(model.args[1],human) + ")";
            } else if (model.functor == "*") {
                return "(" + answerNLG(model.args[0],human) + " * " + answerNLG(model.args[1],human) + ")";
            } else if (model.functor == "/") {
                return "(" + answerNLG(model.args[0],human) + " / " + answerNLG(model.args[1],human) + ")";
            } else if (model.functor == '==') {
                return displayValue(model.args[0],human) + " is equal to " + displayValue(model.args[1],human) + ")";
            } else if (model.functor == '\=') {
                return displayValue(model.args[0],human) + " is not equal to " + displayValue(model.args[1],human) + ")";
            } else { // this should be a real one, now 
                predicate_name = model.functor;
                if (predicate_name == "datetime_diff_duration") {
                    return "the amount of time between " + displayValue(model.args[0],human) + " and " + displayValue(model.args[1],human) + " is " + displayValue(model.args[2],human) 
                }
                if (predicate_name == "lte") {
                    return displayValue(model.args[0],human) + " is less than or equal to " + displayValue(model.args[1],human)
                }
                if (predicate_name == "lt") {
                    return displayValue(model.args[0],human) + " is less than " + displayValue(model.args[1],human)
                }
                if (predicate_name == "gte") {
                    return displayValue(model.args[0],human) + " is greater than " + displayValue(model.args[1],human)
                }
                if (predicate_name == "gt") {
                    return displayValue(model.args[0],human) + " is greater than or equal to" + displayValue(model.args[1],human)
                }
                predicate_type = model.args.length; // 1 is category, 2 is attribute
                var prefix = "";
                var infix = "";
                var postfix = "";
                if (predicate_type == 1) {
                    object = model.args[0]
                    // Check for a category NLG.
                    for (var i=0; i < ontology.CategoryNLG.length; i++) {
                        if (ontology.CategoryNLG[i].Category == predicate_name) {
                            prefix = ontology.CategoryNLG[i].Prefix;
                            postfix = ontology.CategoryNLG[i].Postfix;
                            
                            return prefix + " " + displayValue(object,human) + " " + postfix;
                        }
                    }
                    for (var i=0; i < ontology.AttributeNLG.length; i++) {
                        if (ontology.AttributeNLG[i].Attribute == predicate_name) {
                            prefix = ontology.AttributeNLG[i].Prefix;
                            postfix = ontology.AttributeNLG[i].Postfix;
                            
                            return prefix + " " + displayValue(object,human) + " " + postfix;
                        }
                    }
                    return displayValue(object,human) + " is a " + predicate_name;
                } else { // it is an attribute
                    object = model.args[0];
                    value = model.args[1];
                        
                    for(var i=0; i < ontology.AttributeNLG.length; i++) {
                            
                        if (ontology.AttributeNLG[i].Attribute == predicate_name) {
                            prefix = ontology.AttributeNLG[i].Prefix;
                            postfix = ontology.AttributeNLG[i].Postfix;
                            infix = ontology.AttributeNLG[i].Infix;
                            order = ontology.AttributeNLG[i].Order;
                            if (order == "ov") {
                                return prefix + " " + displayValue(object,human) + " " + infix + " " + displayValue(value,human) + " " + postfix;
                            } else {
                                return prefix + " " + displayValue(value,human) + " " + infix + " " + displayValue(object,human) + " " + postfix;
                            }
                        }
                    }
                    return displayValue(object,human) + "'s " + predicate_name + " is " + displayValue(value,human);
                }
            }
        }

        function convertModelToTree(list, answer, explanation, prefix = "", root = true) {
            output_html = "";
            if (root) {
                prefix = "ex_" + answer + "_" + explanation
                output_html += '<div class="explanation">'
                // An explanation may have more than one root conclusion it
                // is trying to explain. So at this point it is potentially
                // a list of lists, with no text elements.
                // Run this again against each sub-element.
                output_html += "<ul>"
                for (var i = 0; i < list.length; i++) {
                    output_html += "<li>"
                    output_html += convertModelToTree(list[i], answer, explanation, prefix + '_' + i, false)
                    output_html += "</li>"
                }
                output_html += "</ul>"
                output_html += "</div>"
            } else {
                // Now we are inside a given root explanation.
                // Each node is a piece of text, optionally followed by an array
                // of reasons for that piece of text.
                var has_reasons = Array.isArray(list[1]);
                var target = prefix;
                output_html += '<div class="explanation_node">'
                if (has_reasons) {
                    output_html += '<i class="bi bi-caret-right" data-bs-toggle="collapse" data-bs-target="#' + target + '"></i>'
                }
                output_html += addSectionReferences(list[0])
                output_html += '</div>'
                // Now we have displayed the text, we optionally display each of the
                // reasons, processing it using this formula if it, too, has reasons.
                if (has_reasons) {
                    output_html += '<div class="subparts collapse" id="' + target + '">'
                    output_html += "<ul>"
                    for (var j = 0; j < list[1].length; j++) {
                        var reason_has_reasons = Array.isArray(list[1][j + 1]);
                        output_html += "<li>"
                        if (reason_has_reasons) {
                            output_html += convertModelToTree(list[1].slice(j), answer, explanation, target + '_' + j, false)
                            j++;
                        } else {
                            output_html += list[1][j]
                        }
                        output_html += "</li>"
                    }
                    output_html += '</ul></div>'
                }
            }
            return output_html;
        }
        
        function initialize_facts() { // TODO CLEANUP
            categories = ontology['Categories'];
            
            // For each existing object, add it to the fact scenario.
            objects = ontology['Objects'];
            attributes = ontology['Attributes'];
            values = ontology['Values'];
            for (var i=0; i < objects.length; i++) {
                var new_fact_statement = {'from_ontology': true, 'type': 'true','category': objects[i]['Category'], 'object': objects[i]['Object']}
                new_fact_data['facts'].push(new_fact_statement);
            }
            for(var l=0; l<values.length; l++){
                // I have an object, an attribute, and a value, but I don't have a category.
                // So I need to collect the category from the object.
                var value_category;
                for(var m=0; m<objects.length; m++){
                    if(objects[m]['Object'] == values[l]['Object']) {
                        value_category = objects[m]['Category'];
                        break;
                    }
                }
                // Now I should be able to add the value to the object in the fact_data
                var new_fact_statement = {'from_ontology': true, 'type': 'true','attribute': values[l]['Attribute'], 'object': values[l]['Object']}
                if ('Value' in values[l]) {
                    new_fact_statement['value'] = values[l]['Value']
                }
                new_fact_data['facts'].push(new_fact_statement);
            }

        }
        
        
        function draw_facts(){
            var output_html = '<nav class="column" id="facttree">';
            output_html += '<div id="new_known_objects">';
            output_html += draw_new_fact_data();
            output_html += "</div>";
            // TODO: Create an "add object" form, that lets you create objects of any category.
            // Loop through the categories and their NLG, and build the new object forms, here, for display when requested.
            for(var c=0; c < ontology['Categories'].length; c++) {
                if (!hidden_by_view.includes('view_cat_' + ontology['Categories'][c])) {
                    var prefix = "";
                    var postfix = "is a " + ontology['Categories'][c];
                    for (var i=0; i< ontology['CategoryNLG'].length; i++) {
                        if (ontology['CategoryNLG'][i]['Category'] == ontology['Categories'][c]) {
                            prefix = ontology['CategoryNLG'][i]['Prefix'];
                            postfix = ontology['CategoryNLG'][i]['Postfix'];
                            break;
                        }
                    }
                    output_html += '<div class="collapse blawx_new_object row blawx-object tree-element p-2" id="new_category_' + ontology['Categories'][c] + '">';
                    output_html += '<div class="input-group">';
                    output_html += '<span class="input-group-text">It is</span>';
                        
                    output_html += '<div class="input-group-text"><select class="form-select" aria-label="Default select example" id="new_object_truth_value_' + ontology['Categories'][c] + '">';
                    output_html += '<option selected value="true">true that</option>';
                    output_html += '<option value="false">false that</option>';
                    output_html += '<option value="unknown">uncertain whether</option>';
                    output_html += '</select></div>';
                    if (prefix != "") {
                        output_html += '<span class="input-group-text">'+ prefix + '</span>';
                    }
                    output_html += '<div class="input-group-text"><input onclick="toggle_unground_new_object(\'' + ontology['Categories'][c] + '\')" class="form-check-input mt-0 me-1" type="checkbox" value="" aria-label="Checkbox for following text input" id="new_object_toggle_check_' + ontology['Categories'][c] + '"><input onchange="save_new_object(\'' + ontology['Categories'][c] + '\')" type="text" class="form-control" aria-label="New object name" id="new_object_name_' + ontology['Categories'][c] + '">';
                    output_html += '</div>';
                    if (postfix != "") {
                        output_html += '<span class="input-group-text">'+ postfix + '</span>';
                    }
                    output_html += '<button onclick="save_new_object(\'' + ontology['Categories'][c] + '\')" class="btn btn-outline-success" type="button"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-square" viewBox="0 0 16 16">';
                    output_html += '<path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>';
                    output_html += '<path d="M10.97 4.97a.75.75 0 0 1 1.071 1.05l-3.992 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.235.235 0 0 1 .02-.022z"/>';
                    output_html += '</svg></button>';
                    output_html += '<button onclick="cancel_new_object(\'' + ontology['Categories'][c] + '\')" class="btn btn-outline-danger" type="button"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-square" viewBox="0 0 16 16">';
                    output_html += '<path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>';
                    output_html += '<path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>';
                    output_html += '</svg></button></div></div>';
                }
            }
            for(var a = 0; a < ontology['Attributes'].length; a++) {
                if (!hidden_by_view.includes('view_att_' + ontology['Attributes'][a]['Attribute'])) {
                    var prefix;
                    var infix;
                    var postfix;
                    var order;
                    var object_type;
                    var value_type;
                    var attribute_name;
                    attribute_name = ontology['Attributes'][a]['Attribute'];
                    object_type = ontology['Attributes'][a]['Category'];
                    value_type = ontology['Attributes'][a]['Type'];
                    var value_type_is_category;
                    if (['date','time','datetime','duration','number'].includes(value_type)) {
                        value_type_is_category = false;
                    } else {
                        value_type_is_category = true;
                    }
                    for (var i=0; i< ontology['AttributeNLG'].length; i++) {
                        if (ontology['Attributes'][a]['Attribute'] == ontology['AttributeNLG'][i]['Attribute']) {
                            prefix = ontology['AttributeNLG'][i]['Prefix'];
                            infix = ontology['AttributeNLG'][i]['Infix'];
                            postfix = ontology['AttributeNLG'][i]['Postfix'];
                            order = ontology['AttributeNLG'][i]['Order'];
                            break;
                        }
                    }
                    output_html += '<div class="collapse blawx_new_object row blawx-object tree-element p-2" id="new_attribute_' + attribute_name + '">';
                    output_html += '<div class="input-group">';
                    output_html += '<span class="input-group-text">It is</span>';
                        
                    output_html += '<div class="input-group-text"><select class="form-select" aria-label="Default select example" id="new_attribute_truth_type_' + attribute_name + '">';
                    output_html += '<option selected value="true">true that</option>';
                    output_html += '<option value="false">false that</option>';
                    output_html += '<option value="unknown">uncertain whether</option>';
                    output_html += '</select></div>';

                    value_html = ""
                    switch(value_type) {
                        case 'number':
                            value_html += '<div class="input-group-text">';
                            //value_html += '<input onclick="toggle_unground_new_value(\'' + attribute_name + '\')" class="form-check-input mt-0 me-1" type="checkbox" value="" aria-label="Checkbox for following text input">';    
                            value_html += '<input onchange="save_new_value(\'' + attribute_name + '\')" type="number" class="form-control" aria-label="New value" id="new_attribute_value_' + attribute_name + '">';
                            value_html += "</div>";
                            break;
                        case 'date':
                            value_html += '<div class="input-group-text">';
                            //value_html += '<input onclick="toggle_unground_new_value(\'' + attribute_name + '\')" class="form-check-input mt-0 me-1" type="checkbox" value="" aria-label="Checkbox for following text input">';
                            value_html += '<input type="date" class="form-control" aria-label="Date" id="new_attribute_value_' + attribute_name + '">';
                            value_html += "</div>";
                            break;
                        case 'duration':
                            value_html += '<div class="input-group-text">';
                            //value_html += '<input onclick="toggle_unground_new_value(\'' + attribute_name + '\')" class="form-check-input mt-0 me-1" type="checkbox" value="" aria-label="Checkbox for following text input">';
                            value_html += '<span class="input-group-text px-1">S</span>';
                            value_html += '<div class="input-group-text">';
                            value_html += '<input class="form-check-input" type="checkbox" aria-label="Duration Direction" checked id="new_attribute_value_' + attribute_name + '_direction">';
                            value_html += '</div>';
                            value_html += '<span class="input-group-text px-1">Y</span>';
                            value_html += '<input type="number" class="form-control" aria-label="Duration Years" value="0" id="new_attribute_value_' + attribute_name + '_years">';
                            value_html += '<span class="input-group-text px-1" id="basic-addon1">M</span>';
                            value_html += '<input type="number" class="form-control" aria-label="Duration Months" value="0" id="new_attribute_value_' + attribute_name + '_months">';
                            value_html += '<span class="input-group-text px-1" id="basic-addon1">D</span>';
                            value_html += '<input type="number" class="form-control" aria-label="Duration Days" value="0" id="new_attribute_value_' + attribute_name + '_days">';
                            value_html += '<span class="input-group-text px-1" id="basic-addon1">H</span>';
                            value_html += '<input type="number" class="form-control" aria-label="Duration Hours" value="0" id="new_attribute_value_' + attribute_name + '_hours">';
                            value_html += '<span class="input-group-text px-1" id="basic-addon1">M</span>';
                            value_html += '<input type="number" class="form-control" aria-label="Duration Minutes" value="0" id="new_attribute_value_' + attribute_name + '_minutes">';
                            value_html += "</div>";
                            break;
                        case 'boolean':
                            break;
                        case 'time':
                            value_html += '<div class="input-group-text">';
                            //value_html += '<input onclick="toggle_unground_new_value(\'' + attribute_name + '\')" class="form-check-input mt-0 me-1" type="checkbox" value="" aria-label="Checkbox for following text input">';
                            value_html += '<input type="time" class="form-control" aria-label="Date" id="new_attribute_value_' + attribute_name + '">';
                            value_html += "</div>";
                            break;
                        case 'datetime':
                            value_html += '<div class="input-group-text">';
                            //value_html += '<input onclick="toggle_unground_new_value(\'' + attribute_name + '\')" class="form-check-input mt-0 me-1" type="checkbox" value="" aria-label="Checkbox for following text input">';
                            value_html += '<input type="datetime-local" class="form-control" aria-label="Date" id="new_attribute_value_' + attribute_name + '">';
                            value_html += "</div>";
                            break;
                        default:
                            if (value_type_is_category) {
                                value_html += '<div class="input-group-text">';
                                //value_html += '<input onclick="toggle_unground_new_value(\'' + attribute_name + '\')" class="form-check-input mt-0 me-1" type="checkbox" value="" aria-label="Checkbox for following text input">';
                                value_html += '<select class="form-select" aria-label="Default select example" id="new_attribute_value_' + attribute_name + '">';
                                //for (var o=0; o < ontology['Objects'].length; o++) {
                                //    if (ontology['Objects'][o]['Category'] == value_type) {
                                //        value_html += '<option value ="' + ontology['Objects'][o]['Object'] + '">'+ ontology['Objects'][o]['Object'] + '</option>';
                                //    }
                                //}
                                for (var n=0; n < new_fact_data['facts'].length; n++) {
                                    if ('category' in new_fact_data['facts'][n]) {
                                        if (new_fact_data['facts'][n]['category'] == value_type && typeof(new_fact_data['facts'][n]['object']) != "object") {
                                            value_html += '<option value="' + new_fact_data['facts'][n]['object'] + '">' + new_fact_data['facts'][n]['object'] + '</option>';
                                        }
                                    }
                                }
                                //for (var f=0; f < fact_data.length; f++) {
                                //    if ('category' in fact_data[f]) {
                                //        if (fact_data[f]['category'] == value_type) {
                                //            value_html += '<option value ="' + fact_data[f]['object'] + '">'+ fact_data[f]['object'] + '</option>';
                                //        }
                                //    }
                                //}
                                value_html += '<option value="VAR">any ' + value_type + '</option>';
                                value_html += '</select></div>';
                            } else {
                                value_html += "Can't Render Datatype";
                            }
                    }

                    if (prefix != "") {
                        output_html += '<span class="input-group-text">'+ prefix + '</span>';
                    }
                    if (order == "ov") {
                        output_html += '<div class="input-group-text">';
                        //output_html += '<input onclick="toggle_unground_new_value(\'' + attribute_name + '\')" class="form-check-input mt-0 me-1" type="checkbox" value="" aria-label="Checkbox for following text input">';
                        output_html += '<select class="form-select" aria-label="Default select example" id="new_attribute_object_' + attribute_name + '">';
                        //for (var o=0; o < ontology['Objects'].length; o++) {
                        //    if (ontology['Objects'][o]['Category'] == object_type) {
                        //        output_html += '<option value ="' + ontology['Objects'][o]['Object'] + '">'+ ontology['Objects'][o]['Object'] + '</option>';
                        //    }
                        //}
                        for (var n=0; n < new_fact_data['facts'].length; n++) {
                            if ('category' in new_fact_data['facts'][n]) {
                                if (new_fact_data['facts'][n]['category'] == object_type  && typeof(new_fact_data['facts'][n]['object']) != "object") {
                                    output_html += '<option value="' + new_fact_data['facts'][n]['object'] + '">' + new_fact_data['facts'][n]['object'] + '</option>';
                                }
                            }
                        }
                        //for (var f=0; f < fact_data.length; f++) {
                        //    if ('category' in fact_data[f]) {
                        //        if (fact_data[f]['category'] == object_type) {
                        //            output_html += '<option value ="' + fact_data[f]['object'] + '">'+ fact_data[f]['object'] + '</option>';
                        //        }
                        //    }
                        //}
                        output_html += '<option value="VAR">any ' + object_type + '</option>';
                        output_html += '</select></div>';
                    } else {
                        output_html += value_html;
                    }
                    if (infix != "" && infix != "not_applicable") {
                        output_html += '<span class="input-group-text">'+ infix + '</span>';
                    }
                    if (order == "ov") {
                        output_html += value_html;
                    } else {
                        output_html += '<div class="input-group-text">';
                        //output_html += '<input onclick="toggle_unground_new_value(\'' + attribute_name + '\')" class="form-check-input mt-0 me-1" type="checkbox" value="" aria-label="Checkbox for following text input">';
                        output_html += '<select class="form-select" aria-label="Default select example" id="new_attribute_object_' + attribute_name + '">';
                        //for (var o=0; o < ontology['Objects'].length; o++) {
                        //    if (ontology['Objects'][o]['Category'] == object_type) {
                        //        output_html += '<option value ="' + ontology['Objects'][o]['Object'] + '">'+ ontology['Objects'][o]['Object'] + '</option>';
                        //    }
                        //}
                        for (var n=0; n < new_fact_data['facts'].length; n++) {
                            if ('category' in new_fact_data['facts'][n]) {
                                if (new_fact_data['facts'][n]['category'] == object_type && typeof(new_fact_data['facts'][n]['object']) != "object") {
                                    output_html += '<option value="' + new_fact_data['facts'][n]['object'] + '">' + new_fact_data['facts'][n]['object'] + '</option>';
                                }
                            }
                        }
                        //for (var f=0; f < fact_data.length; f++) {
                        //    if ('category' in fact_data[f]) {
                        //        if (fact_data[f]['category'] == object_type) {
                        //            output_html += '<option value ="' + fact_data[f]['object'] + '">'+ fact_data[f]['object'] + '</option>';
                        //        }
                        //    }
                        //}
                        output_html += '<option value="VAR">any ' + object_type + '</option>';
                        output_html += '</select></div>';
                    }
                    if (postfix != "") {
                        output_html += '<span class="input-group-text">'+ postfix + '</span>';
                    }
                    output_html += '<button onclick="save_new_value(\'' + attribute_name + '\')" class="btn btn-outline-success" type="button"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-square" viewBox="0 0 16 16">';
                    output_html += '<path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>';
                    output_html += '<path d="M10.97 4.97a.75.75 0 0 1 1.071 1.05l-3.992 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.235.235 0 0 1 .02-.022z"/>';
                    output_html += '</svg></button>';
                    output_html += '<button onclick="cancel_new_value(\'' + attribute_name + '\')" class="btn btn-outline-danger" type="button"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-square" viewBox="0 0 16 16">';
                    output_html += '<path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>';
                    output_html += '<path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>';
                    output_html += '</svg></button></div></div>';    
                }
            }
            output_html += '<div id="new_objects">';
                output_html += '<div class="dropdown">';
                output_html += '<button class="btn btn-primary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-circle" viewBox="0 0 16 16">';
                output_html += '<path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>';
                output_html += '<path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>';
                output_html += '</svg>Add Fact</button>';
                output_html += '<ul class="dropdown-menu w-100">';
                
                var categories = Object.keys(fact_data);
                
                for(var c=0; c < ontology['Categories'].length; c++) {
                    if (!hidden_by_view.includes('view_cat_' + ontology['Categories'][c])) {
                        var prefix = "";
                        var postfix = "is a " + ontology['Categories'][c];
                        for (var i=0; i< ontology['CategoryNLG'].length; i++) {
                            if (ontology['CategoryNLG'][i]['Category'] == ontology['Categories'][c]) {
                                prefix = ontology['CategoryNLG'][i]['Prefix'];
                                postfix = ontology['CategoryNLG'][i]['Postfix'];
                                break;
                            }
                        }
                        output_html += '<li><a onclick="show_new_object(\'' + ontology['Categories'][c] + '\')" class="dropdown-item" href="#">' + prefix + ' <i>object</i> ' + postfix + '</a></li>';
                    }
                }
                for(var a=0; a < ontology['Attributes'].length; a++) {
                    if (!hidden_by_view.includes('view_att_' + ontology['Attributes'][a]['Attribute'])) {    
                        var attribute_name = ontology['Attributes'][a]['Attribute'];
                        var object_type = ontology['Attributes'][a]['Category'];
                        var value_type = ontology['Attributes'][a]['Type'];
                        for (var i=0; i< ontology['AttributeNLG'].length; i++) {
                            if (attribute_name == ontology['AttributeNLG'][i]['Attribute']) {
                                prefix = ontology['AttributeNLG'][i]['Prefix'];
                                infix = ontology['AttributeNLG'][i]['Infix'];
                                postfix = ontology['AttributeNLG'][i]['Postfix'];
                                order = ontology['AttributeNLG'][i]['Order'];
                                break;
                            }
                        }
                        if (value_type == "boolean") {
                            output_html += '<li><a onclick="show_new_attribute(\'' + attribute_name + '\')" class="dropdown-item" href="#">' + prefix + ' <i>' +  object_type + '</i> ' + postfix + '</a></li>';
                        } else {
                            if (order == "ov") {
                                output_html += '<li><a onclick="show_new_attribute(\'' + attribute_name + '\')" class="dropdown-item" href="#">' + prefix + ' <i>' +  object_type + '</i> ' + infix + ' <i>' + value_type + '</i> ' + postfix + '</a></li>';
                            } else {
                                output_html += '<li><a onclick="show_new_attribute(\'' + attribute_name + '\')" class="dropdown-item" href="#">' + prefix + ' <i>' + value_type + '</i> ' + infix + ' <i>' +  object_type + '</i> ' + postfix + '</a></li>';
                            }
                        }
                    }
                }
                output_html += '</ul>';
                output_html += '</div>';
                output_html += '</div>';
                

            output_html += '</nav>';
            // Output the result to facttree
            var target = document.getElementById('facttree');
            target.outerHTML = output_html;

        };
        function toggle_unground_new_object(category) {
            // Get the value of the checkbox
            var checkbox = document.getElementById('new_object_toggle_check_' + category);
            var grounded = checkbox.checked;
            // Get the target textbox
            var target_input = document.getElementById('new_object_name_' + category);
            // If checked, set the textbox to "ANYTHING" and disable it.
            if (grounded) {
                target_input.value = "any object";
                target_input.disabled = true;
            } else {
                // Otherwise, set the textbox to blank, and enable it.
                target_input.value = "";
                target_input.disabled = false;
            }

        }
        function show_new_object(category){
            
            target = document.getElementById('new_category_' + category);
            target.classList.add('show');

        };
        function show_new_attribute(attribute) {
            target = document.getElementById('new_attribute_' + attribute);
            target.classList.add('show');
        }
        function save_new_object(category){
            // Add the object to the data
            target_name = document.getElementById('new_object_name_' + category);
            target_truth_value = document.getElementById('new_object_truth_value_' + category)
            new_object_name = target.value;
            var new_fact_statement = { 'from_ontology': false, 'type': target_truth_value.value, 'category': category}
            if (target_name.value == "any object") {
                new_fact_statement['object'] = {'variable': 'A'};
            } else {
                new_fact_statement['object'] = target_name.value;
            }
            new_fact_data['facts'].push(new_fact_statement)
            
            // redraw
            draw_facts();
        };
        function cancel_new_object(category){
            // Delete the value in the current new object
            //target_new_object = document.getElementById('category_' + category + '_new_object');
            //target_new_object.value='';
            // Return it to hidden.
            target_category = document.getElementById('new_category_' + category);
            target_category.classList.remove('show');
            // Re-Enable the Lock Button
            //target_button = document.getElementById('category_' + category + '_lock');
            //target_button.removeAttribute('disabled');
        };
        function cancel_new_value(attribute){
            target_attribute = document.getElementById('new_attribute_' + attribute);
            target_attribute.classList.remove('show');
        }
        function show_new_value(category,object,attribute){
            // Close any other open new object or value
            // set the current new object to be visible.
            target = document.getElementById( category + '_' + object + '_' + attribute);
            target.classList.add('blawx_show_new');
            // Set the current "lock" button to disabled.
            target_button = document.getElementById('category_' + category + '_' + object + '_' + attribute + '_lock');
            target_button.setAttribute('disabled','');
            // Move the focus to the new object input.
            // Figure out what type of value this is.
            var attribute_type;
            for(var i =0; i<ontology['Attributes'].length; i++) {
                if(ontology['Attributes'][i]['Category'] == category
                  && ontology['Attributes'][i]['Attribute'] == attribute) {
                    attribute_type = ontology['Attributes'][i]['Type'];
                    break;
                  }
            }
            if (attribute_type == "duration") {
                target_input = document.getElementById('category_' + category + '_' + object + '_' + attribute + '_new_years');
            } else {
                target_input = document.getElementById('category_' + category + '_' + object + '_' + attribute + '_new_value');
            }
            target_input.focus();
        };
        function save_new_value(attribute){
            var truth_target = document.getElementById('new_attribute_truth_type_' + attribute);
            var truth_type = truth_target.value;
            
            // Figure out what type of value this is.
            var attribute_type;
            for(var i =0; i<ontology['Attributes'].length; i++) {
                if(ontology['Attributes'][i]['Attribute'] == attribute) {
                    attribute_type = ontology['Attributes'][i]['Type'];
                    break;
                  }
            }
            
            
            if(attribute_type == "duration") {
                // Get the new value
                direction_target = document.getElementById('new_attribute_value_' + attribute + '_direction');
                year_target = document.getElementById('new_attribute_value_' + attribute + '_years');
                month_target = document.getElementById('new_attribute_value_' + attribute + '_months');
                day_target = document.getElementById('new_attribute_value_' + attribute + '_days');
                hour_target = document.getElementById('new_attribute_value_' + attribute + '_hours');
                minute_target = document.getElementById('new_attribute_value_' + attribute + '_minutes');
                if (direction_target.checked) {
                    new_direction = true;
                } else {
                    new_direction = false;
                }
                new_year = year_target.value;
                new_month = month_target.value;
                new_day = day_target.value;
                new_hour = hour_target.value;
                new_minute = minute_target.value;
                if (new_direction) {
                    new_value = "";
                } else {
                    new_value = "-";
                }
                new_value += "P"
                if (parseInt(new_year)) {
                    new_value += new_year + "Y";
                }
                if (parseInt(new_month)) {
                    new_value += new_month + "M";
                }
                // The idea here is that if all three are zero, it should come out as P0D
                if (parseInt(new_day) || (!parseInt(new_year) && !parseInt(new_month))) {
                    new_value += new_day + "D";
                }
                if (parseInt(new_hour) || parseInt(new_minute)) {
                    new_value += "T";
                }
                if (parseInt(new_hour)) {
                    new_value += new_hour + "H";
                }
                if (parseInt(new_minute)) {
                    new_value += new_minute + "M";
                }
            } else if (attribute_type != "boolean") {
                // Get the new value
                target = document.getElementById('new_attribute_value_' + attribute);
                new_value = target.value;    
            }
            var target_object = document.getElementById('new_attribute_object_' + attribute);
            var new_object = target_object.value;
            var new_fact_statement = {'from_ontology': false, 'type': truth_type, 'attribute': attribute};
            if (new_object != "VAR") {
                new_fact_statement['object'] = new_object;
            } else {
                new_fact_statement['object'] = {'variable': 'object'};
            }
            if (attribute_type != "boolean") {
                if (new_value != "VAR") {
                    new_fact_statement['value'] = new_value;
                } else {
                    new_fact_statement['value'] = {'variable': 'value'}
                }
            }
            new_fact_data['facts'].push(new_fact_statement);
            //fact_data[category]['members'][object][attribute]['values'].push(new_value);
            //expanded[category + "_" + object + '_' + attribute + "_content"] = true;
            // redraw
            draw_facts();
        };
        
        draw_facts();
        var answer_element = document.getElementById('answers');
        var payload_element = document.getElementById('payload');
        var response_element = document.getElementById('response');
        function run_test() {
            var testrun_request = new XMLHttpRequest();
            testrun_request.onload = function () {
                parsed_test_response = JSON.parse(this.responseText);
                console.log("Test response received")
                payload_element.innerHTML = '<pre>' + JSON.stringify(new_fact_data,null,2) + '</pre>'
                
                response_element.innerHTML = '<pre>' + JSON.stringify(parsed_test_response,null,2) + '</pre>'
                // If the question is answered
                if (parsed_test_response['Answers'].length) {
                    // Display the answer
                    var output_content = '<div class="accordion accordion-flush">';
                    var answers = parsed_test_response.Answers;
                    for (let i = 0; i < answers.length; i++) {
                        var count = i + 1;
                        var heading_name = "answer_" + count + "_heading";
                        var collapse_name = "answer_" + count + "_collapse";
                        output_content += '<div class="accordion-item"><h2 class="accordion-header" id="' + heading_name + '">';
                        output_content += '<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#' + collapse_name + '" aria-expanded="false" aria-controls="' + collapse_name + '">';
                        output_content += 'Answer #' + count;
                        var variables = answers[i].Variables;
                        output_content += '</button></h2>';
                        output_content += '<div id="' + collapse_name + '" class="accordion-collapse collapse" aria-labelledby="' + heading_name + '" style="">';
                        models = answers[i].Models;
                        output_content += '<div class="accordian accordian-flush">'
                        output_content += '<ul>'
                        var attributes_output = "";
                        for (var key in variables) {
                            output_content += '<li>' + key + ': ' + displayValue(variables[key]) + '</li>';
                        }
                        output_content += attributes_output;
                        output_content += '</ul>'

                        for (let j = 0; j < models.length; j++) {
                            var model_count = j + 1;
                            var model_heading_name = "answer_" + count + "_model_" + model_count + "_heading";
                            var model_collapse_name = "answer_" + count + "_model_" + model_count + "_collapse";
                            output_content += '<div class="accordion-item"><h2 class="accordion-header" id="' + model_heading_name + '">';
                            output_content += '<button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#' + model_collapse_name + '" aria-expanded="false" aria-controls="' + model_collapse_name + '">';
                            output_content += 'Explanation #' + model_count;
                            output_content += '</button></h2>';
                            output_content += '<div id="' + model_collapse_name + '" class="accordion-collapse collapse" aria-labelledby="' + model_heading_name + '" style="">';
                            for (var attribute in models[j]['Residuals']) {
                                if ((models[j]['Residuals'][attribute]['functor'] == "put_attr" && models[j]['Residuals'][attribute]['args'][1] == 'scasp_output' && models[j]['Residuals'][attribute]['args'][2] == 'singleton')||
                                models[j]['Residuals'][attribute]['functor'] == "put_attr" && models[j]['Residuals'][attribute]['args'][1] == 'scasp_output' && models[j]['Residuals'][attribute]['args'][2]['functor'] == 'name') {
                                    // This is designed to prevent re-printing information about the Attributes that is already displayed.
                                    // If the only thing present int he attributes is the name, just skip it.
                                    continue;
                                } else if (models[j]['Residuals'][attribute]['functor'] == "โ") {
                                    // This is an inequality constraint
                                    attributes_output += "<li>where " + models[j]['Residuals'][attribute]['args'][0] + " is not ";
                                    if (models[j]['Residuals'][attribute]['args'][1].length > 1) {
                                        attributes_output += "one of ";
                                    }
                                    attributes_output += models[j]['Residuals'][attribute]['args'][1].toString() + "</li>"
                                } else if (models[j]['Residuals'][attribute]['functor'] == "{}") {
                                    attributes_output += "<li>where" + models[j]['Residuals'][attribute]['args'][0]['args'][0] + " " + models[j]['Residuals'][attribute]['args'][0]['functor'] + " " + models[j]['Residuals'][attribute]['args'][0]['args'][1] + "</li>";
                                } else {
                                    // It should throw a console warning if there was something else in there.
                                    console.warn("Unrecognized attribute in output: " + attribute['functor'] + ".");
                                }
                            }
                                
                            //output_content += convertModelToTree(models[j].Tree, count, model_count);
                            getExplanationNodeIndex(models[j].Raw,i,j)
                            var explanations = getNodesFromModel(models[j].Raw,false,i,j);
                            var displayed_nodes = [];
                            for (var k = 0; k < explanations.length; k++) {
                                if (!displayed_nodes.includes(explanations[k].name)) { // To eliminate duplicates caused by "proved" method.
                                    output_content += explanations[k].content;
                                    displayed_nodes.push(explanations[k].name);
                                }
                            }
                            //output_content += getNodesFromModel(models[j].Raw);
                            // output_content += convertModelToParagraphs(models[j].Raw);
                            output_content += '</div></div>';

                        }
                        output_content += '</div></div></div>';
                    }
                    output_content += '</div>';
                    answer_element.innerHTML = output_content;

                    $('#nav-answers-tab').tab('show');
                    draw_facts(); // So that new relevance information will be displayed in the interface.
                } else {
                    // Indicate that there are no answers.
                    answer_element.innerHTML = "No answers received.";
                    
                    $('#nav-answers-tab').tab('show');
                }
            }
            testrun_request.open("POST", "{% url 'test_interview' blawxtest.ruledoc.id blawxtest %}");
            testrun_request.setRequestHeader("Content-Type", "application/json");
            console.log("Sending test request");
            answer_element.innerHTML = "Thinking...";
            testrun_request.setRequestHeader('X-CSRFToken', csrftoken);
            testrun_request.send(JSON.stringify(new_fact_data));
        }
        var view_form_element = document.getElementById('viewform');
        function toggle_view_hidden(input) {
            index = hidden_by_view.indexOf(input);
            if(index > -1) {
                hidden_by_view.splice(index,1);
            } else {
                hidden_by_view.push(input);
            }
            draw_facts();
        }
        function draw_view_form() {
            output = "<ul>";
            // For each category
            for(var i=0; i < ontology['Categories'].length; i++) {
                // Ask if they want to hide that category
                output += "<li>";
                output += '<div class="form-check form-switch">';
                output += '<input onchange="toggle_view_hidden(\'' + 'view_cat_' + ontology['Categories'][i] + '\')" class="form-check-input" type="checkbox" role="switch" id="view_cat_' + ontology['Categories'][i] + '"';
                if (hidden_by_view.includes('view_cat_' + ontology['Categories'][i])) {
                    output += ' checked';
                }
                output += '>';
                output += '<label class="form-check-label" for="view_cat_' + ontology['Categories'][i] + '">Hide Category ' + ontology['Categories'][i] + '</label>';
                output += '</div>';
                output += '</li>';
            }
            // For each attribute
            for(var j=0; j < ontology['Attributes'].length; j++) {
                // Ask if they want to hide that attribute for all objects in the category
                output += '<li>';
                output += '<div class="form-check form-switch">';
                output += '<input onchange="toggle_view_hidden(\'' + 'view_att_' + ontology['Attributes'][j]['Attribute'] + '\')" class="form-check-input" type="checkbox" role="switch" id="view_att_' + ontology['Attributes'][j]['Attribute'] + '"';
                if(hidden_by_view.includes('view_att_' + ontology['Attributes'][j]['Attribute'])) {
                    output += ' checked';
                }
                output += '>';
                output += '<label class="form-check-label" for="view_att_' + ontology['Attributes'][j]['Attribute'] + '">Hide Attribute ' + ontology['Attributes'][j]['Attribute'] + '</label>';
                output += '</div>';
                output += '</li>';
            }
            output += '</ul>';
            view_form_element.innerHTML = output;
        }
        draw_view_form();
        function save_view() {
            var payload = {};
            view_update_request = new XMLHttpRequest();
            view_update_request.onload = function() {
                console.log("Test Update Sent");
            }
            view_update_request.open("POST", "{% url 'update_test_view' blawxtest.ruledoc.id blawxtest %}");
            view_update_request.setRequestHeader("Content-Type", "application/json");
            console.log("Sending test view update");
            view_update_request.setRequestHeader('X-CSRFToken', csrftoken);
            payload.view = hidden_by_view;
            view_update_request.send(body=JSON.stringify(payload));
        }
        function save_fact_scenario() {
            var payload = {};
            save_fact_request = new XMLHttpRequest();
            save_fact_request.onload = function() {
                console.log("Fact Sceanrio Sent");
            }
            save_fact_request.open("POST", "{% url 'save_fact_scenario' blawxtest.ruledoc.id blawxtest %}");
            save_fact_request.setRequestHeader("Content-Type", "application/json");
            console.log("Sending Fact Update");
            save_fact_request.setRequestHeader('X-CSRFToken', csrftoken);
            payload.fact_scenario = new_fact_data;
            save_fact_request.send(body=JSON.stringify(payload));
        }
        function draw_new_fact_data() {
            var output_html = ""
            
            output_html += "<h3>Facts</h3><ul>"
            for(var f=0; f < new_fact_data['facts'].length; f++) {
                var hidden = false;
                if ('category' in new_fact_data['facts'][f]) {
                    if (hidden_by_view.includes('view_cat_' + new_fact_data['facts'][f]['category'])) {
                        hidden = true;
                    }
                } else {
                    if (hidden_by_view.includes('view_att_' + new_fact_data['facts'][f]['attribute'])) {
                        hidden = true;
                    }
                }
                if (!hidden) {
                    output_html += "<li>";
                    if (new_fact_data['facts'][f]['type'] != "true") {
                        if (new_fact_data['facts'][f]['type'] == "false") {
                            output_html += "it is false that ";
                        }
                        if (new_fact_data['facts'][f]['type'] == "unknown") {
                            output_html += "it is uncertain whether ";
                        }
                    } 
                    //else {
                        //output_html += "it is true that ";
                    //}
                    if ('category' in new_fact_data['facts'][f]) {
                        var prefix = "";
                        var postfix = "";
                        for (var i=0; i< ontology['CategoryNLG'].length; i++) {
                            if (ontology['CategoryNLG'][i]['Category'] == new_fact_data['facts'][f]['category']) {
                                prefix = ontology['CategoryNLG'][i]['Prefix'];
                                postfix = ontology['CategoryNLG'][i]['Postfix'];
                                break;
                            }
                        }
                        var object_display = new_fact_data['facts'][f]['object'];
                        if (typeof(new_fact_data['facts'][f]['object']) == 'object') {
                            object_display = "any object"
                        }
                        output_html += prefix + ' ' + object_display + ' ' + postfix;
                    } else {
                        var attribute_name = new_fact_data['facts'][f]['attribute'];
                        for (var i=0; i< ontology['AttributeNLG'].length; i++) {
                            if (attribute_name == ontology['AttributeNLG'][i]['Attribute']) {
                                prefix = ontology['AttributeNLG'][i]['Prefix'];
                                infix = ontology['AttributeNLG'][i]['Infix'];
                                postfix = ontology['AttributeNLG'][i]['Postfix'];
                                order = ontology['AttributeNLG'][i]['Order'];
                                break;
                            }
                        }
                        var object_display = new_fact_data['facts'][f]['object'];
                        if (typeof(object_display) == 'object') {
                            for (var a=0; a < ontology['Attributes'].length; a++) {
                                if (attribute_name == ontology['Attributes'][a]['Attribute']) {
                                    attribute_type = ontology['Attributes'][a]['Category'];
                                    break;
                                }
                            }
                            object_display = "any " + attribute_type; 
                        }
                        if ('value' in new_fact_data['facts'][f]) {
                            var value_display = new_fact_data['facts'][f]['value'];
                            for (var c=0; c < ontology['Attributes'].length; c++) {
                                if (attribute_name == ontology['Attributes'][c]['Attribute']) {
                                    value_type = ontology['Attributes'][c]['Type'];
                                }
                            }
                            if (typeof(value_display) == 'object') {   
                                value_display = "any " + value_type;
                            }
                            if (value_type == "duration") {
                                iso_duration = /^(-)?P(\d+Y)?(\d+M)?(\d+D)?T?(\d+H)?(\d+M)?(\d+S)?$/
                                matches = iso_duration.exec(value_display)
                                var new_value_display = ""
                                var future = true;
                                if (matches[1] != undefined) {
                                    future = false;
                                }
                                if (matches[2] != undefined) {
                                    new_value_display += matches[2].slice(0,-1) + " years, ";
                                }
                                if (matches[3] != undefined) {
                                    new_value_display += matches[3].slice(0,-1) + " months, ";
                                }
                                if (matches[4] != undefined) {
                                    new_value_display += matches[4].slice(0,-1) + " days, ";
                                }
                                if (matches[5] != undefined) {
                                    new_value_display += matches[5].slice(0,-1) + " hours, ";
                                }
                                if (matches[6] != undefined) {
                                    new_value_display += matches[6].slice(0,-1) + " minutes, ";
                                }
                                if (matches[7] != undefined) {
                                    new_value_display += matches[7].slice(0,-1) + " seconds, ";
                                }
                                if (future) {
                                    new_value_display += " into the future";
                                } else {
                                    new_value_display += " into the past";
                                }
                                var last_comma = new_value_display.lastIndexOf(',');
                                value_display = new_value_display.slice(0,last_comma) + new_value_display.slice(last_comma+1);

                            }
                            if (value_type == "datetime") {
                                value_display = value_display.replace("T"," ")
                            }
                            if (order == "ov") {
                                output_html += prefix + ' ' +  object_display + ' ' + infix + ' ' + value_display + ' ' + postfix;
                            } else {
                                output_html += prefix + ' ' + value_display + ' ' + infix + ' ' +  object_display + ' ' + postfix;
                            }
                        } else {
                            output_html += prefix + ' ' +  object_display + ' ' + postfix ;
                        }
                    }
                    if (!new_fact_data['facts'][f]['from_ontology']) {
                        var delete_target
                        output_html += '<button type="button" class="btn-close" onclick="delete_fact('+ JSON.stringify(new_fact_data['facts'][f]).replaceAll('"',"\'") +')" aria-label="Delete"></button>';
                    } else {
                        output_html += '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-lock" viewBox="0 0 16 16">';
                        output_html += '<path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z"/>';
                        output_html += '</svg>';
                    }
                    output_html += "</li>";
                }
            }
            output_html += "</ul>";
            if ('Relevant Statements' in parsed_test_response) {

                if (parsed_test_response['Relevant Statements'].length > 0) {
                    output_html += "<h3>Relevant Statements</h3>";
                    output_html += "<p>Answers to the following questions would be relevant for finding non-contingent answers to the question:</p>"
                    output_html += "Is it true that... <ul>";
                    for (var r=0; r < parsed_test_response['Relevant Statements'].length; r++) {
                        output_html += "<li>" + answerNLG(parsed_test_response['Relevant Statements'][r])
                        output_html += "?</li>";
                    }
                    output_html += "</ul>";
                }           
            }
            return output_html;
        }
        function delete_fact(fact) {
            var target_index = -1;
            for (var ind=0; ind < new_fact_data['facts'].length; ind++) {
                if (JSON.stringify(new_fact_data['facts'][ind]) == JSON.stringify(fact)) {
                    target_index = ind;
                    break;
                }
            }
            if (target_index > -1) {
                new_fact_data['facts'].splice(target_index,1);
            }
            draw_facts();
        }
    </script>
</body>
</html>